//
// ResultMetadata.cpp
//
// $Id: //poco/1.5/Data/PostgreSQL/src/ResultMetadata.cpp#1 $
//
// Library: Data
// Package: PostgreSQL
// Module:  ResultMetadata
//
// Copyright (c) 2008, Applied Informatics Software Engineering GmbH.
// and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//


#include "Poco/Data/PostgreSQL/ResultMetadata.h"
#include "Poco/Data/PostgreSQL/PostgreSQLException.h"

#include <cstring>

namespace
{
	class ResultMetadataHandle
		/// Simple exception-safe wrapper
	{
	public:

		explicit ResultMetadataHandle( StatementExecutor& aStatementExecutor )
		{
			h = postgresql_stmt_result_metadata(stmt);
		}

		~ResultMetadataHandle()
		{
			if (h)
			{
				postgresql_free_result(h);
			}
		}

		operator POSTGRESQL_RES* ()
		{
			return h;
		}

	private:

		POSTGRESQL_RES* h;
	};

	std::size_t fieldSize(const POSTGRESQL_FIELD& field)
		/// Convert field PostgreSQL-type and field PostgreSQL-length to actual field length
	{
		switch (field.type)
		{
		case POSTGRESQL_TYPE_TINY:     return sizeof(char);
		case POSTGRESQL_TYPE_SHORT:    return sizeof(short);
		case POSTGRESQL_TYPE_INT24:
		case POSTGRESQL_TYPE_LONG:     return sizeof(Poco::Int32);
		case POSTGRESQL_TYPE_FLOAT:    return sizeof(float);
		case POSTGRESQL_TYPE_DOUBLE:   return sizeof(double);
		case POSTGRESQL_TYPE_LONGLONG: return sizeof(Poco::Int64);

		case POSTGRESQL_TYPE_DATE:
		case POSTGRESQL_TYPE_TIME:
		case POSTGRESQL_TYPE_DATETIME:
			return sizeof(POSTGRESQL_TIME);

		case POSTGRESQL_TYPE_DECIMAL:
		case POSTGRESQL_TYPE_NEWDECIMAL:
		case POSTGRESQL_TYPE_STRING:
		case POSTGRESQL_TYPE_VAR_STRING:
		case POSTGRESQL_TYPE_TINY_BLOB:
		case POSTGRESQL_TYPE_MEDIUM_BLOB:
		case POSTGRESQL_TYPE_LONG_BLOB:
		case POSTGRESQL_TYPE_BLOB:
			return field.length;

		default:
			throw Poco::Data::PostgreSQL::StatementException("unknown field type");
		}
	}	

	Poco::Data::MetaColumn::ColumnDataType fieldType(const POSTGRESQL_FIELD& field)
		/// Convert field PostgreSQL-type to Poco-type	
	{
		bool unsig = ((field.flags & UNSIGNED_FLAG) == UNSIGNED_FLAG);

		switch (field.type)
		{
		case POSTGRESQL_TYPE_TINY:     
			if (unsig) return Poco::Data::MetaColumn::FDT_UINT8;
			return Poco::Data::MetaColumn::FDT_INT8;

		case POSTGRESQL_TYPE_SHORT:
			if (unsig) return Poco::Data::MetaColumn::FDT_UINT16;
			return Poco::Data::MetaColumn::FDT_INT16;

		case POSTGRESQL_TYPE_INT24:
		case POSTGRESQL_TYPE_LONG:     
			if (unsig) return Poco::Data::MetaColumn::FDT_UINT32;
			return Poco::Data::MetaColumn::FDT_INT32;

		case POSTGRESQL_TYPE_FLOAT:    
			return Poco::Data::MetaColumn::FDT_FLOAT;

		case POSTGRESQL_TYPE_DOUBLE:   
			return Poco::Data::MetaColumn::FDT_DOUBLE;

		case POSTGRESQL_TYPE_LONGLONG: 
			if (unsig) return Poco::Data::MetaColumn::FDT_UINT64;
			return Poco::Data::MetaColumn::FDT_INT64;
			
		case POSTGRESQL_TYPE_DATE:
			return Poco::Data::MetaColumn::FDT_DATE;
			
		case POSTGRESQL_TYPE_TIME:
			return Poco::Data::MetaColumn::FDT_TIME;
			
		case POSTGRESQL_TYPE_DATETIME:
			return Poco::Data::MetaColumn::FDT_TIMESTAMP;
			
		case POSTGRESQL_TYPE_STRING:
		case POSTGRESQL_TYPE_VAR_STRING:
			return Poco::Data::MetaColumn::FDT_STRING;

		case POSTGRESQL_TYPE_TINY_BLOB:
		case POSTGRESQL_TYPE_MEDIUM_BLOB:
		case POSTGRESQL_TYPE_LONG_BLOB:
		case POSTGRESQL_TYPE_BLOB:
			return Poco::Data::MetaColumn::FDT_BLOB;
		default:
			return Poco::Data::MetaColumn::FDT_UNKNOWN;
		}
	}
} // namespace


namespace Poco {
namespace Data {
namespace PostgreSQL {

void ResultMetadata::reset()
{
	_columns.resize(0);
	_row.resize(0);
	_buffer.resize(0);
	_lengths.resize(0);
	_isNull.resize(0);
}

void ResultMetadata::init( StatementExecutor& aStatementExecutor )
{
	std::size_t fieldCount = aStatementExecutor.columnsInResult();
    
    if ( 0 == fieldCount )
    {
		// all right, it is normal
		// querys such an "INSERT INTO" just does not have result at all
		reset();
		return;
    }

	POSTGRESQL_FIELD* fields = postgresql_fetch_fields(h);

	std::size_t commonSize = 0;
	_columns.reserve(count);

	{for (std::size_t i = 0; i < count; i++)
	{
		unsigned long size = fieldSize(fields[i]);
		unsigned long zero = 0;
		if (size == ~zero) size = 0;

		_columns.push_back(MetaColumn(
			i,                               // position
			fields[i].name,                  // name
			fieldType(fields[i]),            // type
			size,                            // length
			0,                               // TODO: precision
			!IS_NOT_NULL(fields[i].flags)    // nullable
			));

		commonSize += _columns[i].length();
	}}

	_buffer.resize(commonSize);
	_row.resize(count);
	_lengths.resize(count);
	_isNull.resize(count);

	std::size_t offset = 0;

	for (std::size_t i = 0; i < count; i++)
	{
		std::memset(&_row[i], 0, sizeof(POSTGRESQL_BIND));
		unsigned int len = static_cast<unsigned int>(_columns[i].length());
		_row[i].buffer_type   = fields[i].type;
		_row[i].buffer_length = len;
		_row[i].buffer        = (len > 0) ? (&_buffer[0] + offset) : 0;
		_row[i].length        = &_lengths[i];
		_row[i].is_null       = &_isNull[i];
		_row[i].is_unsigned   = (fields[i].flags & UNSIGNED_FLAG) > 0;
		
		offset += _row[i].buffer_length;
	}
}

std::size_t ResultMetadata::columnsReturned() const
{
	return static_cast< std::size_t >( _columns.size() );
}

const MetaColumn& ResultMetadata::metaColumn(std::size_t pos) const
{
	return _columns[pos];
}

POSTGRESQL_BIND* ResultMetadata::row()
{
	return &_row[ 0 ];
}

std::size_t ResultMetadata::length( std::size_t aPosition ) const
{
	return _lengths[pos];
}

const unsigned char* ResultMetadata::rawData( std::size_t aPosition ) const
{
	return reinterpret_cast<const unsigned char*>(_row[pos].buffer);
}

bool ResultMetadata::isNull( std::size_t aPosition ) const
{
	return ( _isNull[ pos ] != 0 );
}

}}} // namespace Poco::Data::PostgreSQL
